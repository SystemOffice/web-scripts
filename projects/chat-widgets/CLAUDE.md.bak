# CLAUDE.md

## Code Style

- Write subatomic commits: one small change per commit
- Keep functions under 20 lines
- Use descriptive variable names (no abbreviations)
- Add whitespace between logical blocks
- Prefer early returns over nested conditionals

## Commands

```sh
npm run build:dev   # build dist/chat-widgets-dev.js (use during development)
npm run build:prod  # build dist/chat-widgets.js (production — see warning below)
npm test            # run Jest test suite
```

## Build System

- Bundler: esbuild (`build.js` at project root)
- CSS is inlined into the JS bundle via a plugin in `build.js` — no separate CSS file is output
- `npm run build` defaults to `build:dev`

### Delivery

- Files are served via jsDelivr CDN directly from this repo
- jsDelivr handles minification — do not add `minify: true` to esbuild config
- Production URL: `.../dist/chat-widgets.js`
- Dev/staging URL: `.../dist/chat-widgets-dev.js`

### CRITICAL: do not rebuild production manually

- `dist/chat-widgets.js` is the live production file
- **Never run `npm run build:prod` unless intentionally releasing to production**
- Only `npm run build:dev` should be run during development and testing

## Two-Dist Strategy

The project maintains two build outputs with different purposes:

| File | Purpose | Logger/ErrorHandler |
|---|---|---|
| `dist/chat-widgets.js` | Production, served to end users | Stripped down (production versions) |
| `dist/chat-widgets-dev.js` | Dev/staging, for testing SDK integrations | Currently same source — dev versions of logger/error-handler not yet implemented |

### Work in progress

- `logger.js` and `error-handler.js` were stripped down for production (removed session tracking, log history, recovery strategies, etc.)
- The dev build should eventually use full-featured versions of these files
- When implementing: create `logger.dev.js` and `error-handler.dev.js`, then wire them into `build.js` for the dev target

## logger.js and error-handler.js

These were deliberately stripped down. Here is what was removed and why:

**logger.js** (330 → 84 lines)
- Removed: session tracking, in-memory log history, search/query methods, buffer + external sending, performance metrics, `attachToWindow`, `exportLogs`
- Kept: `shouldLog()` level filtering, console output, all public lifecycle log methods
- Reason: overhead not justified for a third-party widget injected into customer pages

**error-handler.js** (306 → 115 lines)
- Removed: all stub recovery strategies (`recoverFromScriptLoad`, `recoverFromInitialization`, etc.), `attemptRecovery`, `determineRecoveryStrategy`, `reportError`
- Kept: circuit breaker (`activateCircuitBreaker`, `resetCircuitBreaker`, `isCircuitBreakerActive`), global error listener, error counting, `logError`
- Reason: recovery strategies were stubs/placeholders with no real implementation; circuit breaker is the only load-bearing piece

## Testing Requirements

- Every function needs a corresponding test
- Use descriptive test names: `test_functionName_scenario_expectedResult`
- Run tests before committing: `npm test`
- Tests live in `tests/` and mirror the source file they cover (e.g. `tests/config.test.js`)
- When adding tests, verify they actually fail when the code is broken before committing

### Test setup

- Framework: Jest 29 with ESM support (`"type": "module"` in package.json)
- Run with: `node --experimental-vm-modules node_modules/.bin/jest`
- Config: `jest.config.js` at project root
- `jest` global must be explicitly imported: `import { jest } from '@jest/globals'`
- For files that use browser globals (`navigator`, `window`), set `globalThis` before dynamic import

### What is testable

Pure logic with no DOM dependency — write unit tests for these:

- `config.js` — `WidgetConfig` defaults, merging, validation, backoff calculation
- `state.js` — `ChatWidgetState` widget activation, deactivation, `hideAll()`
- `logger.js` — log level filtering, format output, console routing, `logScriptLoad` branching
- `error-handler.js` — circuit breaker state transitions, error counts, `handleWidgetError`

### What is not testable here

Requires a live browser DOM or third-party SDKs — do not attempt unit tests for:

- Widget `mount()`, `activate()`, `deactivate()` (depend on `document`/`window`)
- `attachCloseListener()` and `MutationObserver` logic in `anthology.js`
- Script injection and third-party SDK calls (Zoom, Amazon Connect, IntraSee)

## File Structure

- One component/class per file
- Group related files in directories
- Widgets live in `widgets/`, tests live in `tests/`

## Commit Messages

- Format: `type(scope): description`
- Types: `fix`, `feat`, `refactor`, `test`, `docs`
- Keep under 50 characters
- Do NOT add `Co-Authored-By` trailers

## Diagnostic Test Page

- URL: `https://chatbotnonprod.wpengine.com/gcc-newui-dualbuttons/`
- All 3 widgets present: Zoom (`'Zoom'`), Anthology (`'Live Chat'`), Chatbot (`'Bot'`)
- Run: `node diagnose-widgets.mjs` — Puppeteer-based integration tests for widget activation and switching

## Releasing to Production (dev bundle)

To update the live `chat-widgets-dev.js` on jsDelivr:

1. Remove `CLAUDE.md` temporarily (it must not be included in the release)
2. From the repo root, run: `python3 scripts/cli.py release chat-widgets-wip --create-pr`
3. Restore `CLAUDE.md` immediately after
4. Merge the PR in the production repo (`web-scripts`)
5. Wait for jsDelivr cache to refresh

**Important**: The release copies your current filesystem state. Commit or clean your working directory first.

## Before Making Changes

1. Read existing code first
2. Run existing tests: `npm test`
3. Make the smallest possible change
4. Add/update tests
5. Verify all tests pass
